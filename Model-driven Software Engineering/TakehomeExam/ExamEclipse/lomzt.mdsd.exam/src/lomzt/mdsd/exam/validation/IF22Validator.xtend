/*
 * generated by Xtext 2.26.0
 */
package lomzt.mdsd.exam.validation

import lomzt.mdsd.exam.iF22.Scenario
import org.eclipse.xtext.validation.Check
import lomzt.mdsd.exam.iF22.ExternalImport
import lomzt.mdsd.exam.iF22.Location
import lomzt.mdsd.exam.iF22.Expression
import lomzt.mdsd.exam.iF22.Question
import lomzt.mdsd.exam.iF22.This
import lomzt.mdsd.exam.iF22.Target
import lomzt.mdsd.exam.iF22.ExternalCall
import static lomzt.mdsd.exam.Utilities.*
import lomzt.mdsd.exam.iF22.Story
import lomzt.mdsd.exam.iF22.IF22Package
import lomzt.mdsd.exam.iF22.End
import lomzt.mdsd.exam.iF22.Type
import lomzt.mdsd.exam.iF22.EndingTarget
import lomzt.mdsd.exam.iF22.TypeValue

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class IF22Validator extends AbstractIF22Validator {

	@Check
	def checkScenarioNameUnique(Scenario scenario) {
		val parent = getParentOfType(scenario, typeof(Story))
		for (os : parent.scenarios) {
			if (os != scenario && os.name == scenario.name) {
				error("Two scenarios may not have the same name.", IF22Package.Literals.TARGETABLE__NAME)
			}
		}
	}
	
	@Check
	def checkFunctionNameUnique(ExternalImport ei) {
		val parent = getParentOfType(ei, typeof(Story))
		for (oi : parent.imports) {
			if (oi != ei && oi.name == ei.name) {
				error("Two imports may not have the same name.", IF22Package.Literals.EXTERNAL_IMPORT__NAME)
			}
		}
	}
	
	@Check
	def checkLocationNameUnique(Location location) {
		val parent = getParentOfType(location, typeof(Scenario))
		for (otherLocation : parent.locations) {
			if (otherLocation != location && otherLocation.name == location.name) {
				error("Two locations may not have the same name.", IF22Package.Literals.TARGETABLE__NAME)
			}
		}
	}
	
	@Check
	def ensureAtLeastOneEndStatement(Scenario scenario) {
		val count = scenario.locations.stream().filter(x | x instanceof End).count()
		if (count < 1) {
			error ("Must have at least one end statement.", IF22Package.Literals.SCENARIO__LOCATIONS)
		}
	}
	
	@Check
	def ensureTypeComparisonOnlyInInputValidation(TypeValue exp) {
		val question = getParentOfType(exp, typeof(Question))
		val children = getChildrenOfType(question.validate, typeof(TypeValue))
		if (!children.contains(exp)) {
			error("Type decleration is only valid within the context of input validation", IF22Package.Literals.TYPE_VALUE__TYPE)
		}
	}
	
	@Check
	def ensureOnlyOneTypeInInputValidation(Question question) {
		val children = getChildrenOfType(question.validate, TypeValue).size();
		if (children != 1) {
			error("Must have only a single type declaration in input validation.", IF22Package.Literals.QUESTION__VALIDATE)
		}
	}
	
	@Check
	def ensureThisOnlyInTargetExpressions(This obj) {
		val hasTargetParent = getParentOfType(obj, typeof(Target))
		if (hasTargetParent == false) {
			error("'this' keyword can only be used within the context of a target.", IF22Package.Literals.TARGET__CONDITION)
		}
	}
	
	@Check
	def ensureOnKeywordsOnlyWithExternalScenario(EndingTarget endingTarget) {
		val target = getParentOfType(endingTarget, typeof(Target))
		if (!(target.target instanceof Scenario)) {
			error("'on' keyword only applicable when moving to another scenario.", IF22Package.Literals.ENDING_TARGET__FROM)
		}
	}
	
	@Check
	def ensureFunctionArgsMatchSignature(ExternalCall call) {
		val ip = call.func;
		if (call.func.params.size() != call.args.size()) {
			error("Number of arguments does not match number of parameters.", IF22Package.Literals.TARGET__ARGS)
		}
		for (var i = 0; i < ip.params.size(); i++) {
			val expType = getExpressionOutputType(call.args.get(i))
			val paramType = typeToJavaType(ip.params.get(i))
			if (!expType.equals(paramType)) {
				error("Arguments does not match function signature.", IF22Package.Literals.EXTERNAL_CALL__ARGS)
			}
		}
	}
	
	@Check
	def ensureScenarioArgsMatchSignature(Target target) {
		if (target.target instanceof Scenario) {
			val scenario = target.target as Scenario;
			if (scenario.params.size() != target.args.size()) {
				error("Number of arguments does not match number of parameters.", IF22Package.Literals.TARGET__ARGS)
			}
			for (var i = 0; i < scenario.params.size(); i++) {
				val expType = getExpressionOutputType(target.args.get(i))
				val paramType = typeToJavaType(scenario.params.get(i).type)
				if (!expType.equals(paramType)) {
					error("Arguments does not match scenario signature.", IF22Package.Literals.TARGET__ARGS)
				}
			}
		}
	}
	
	@Check
	def ensureQuestionInputMatchVariableType(Question question) {
		if (question.binding != null) {
			val questionInputType = inputType(question)
			val bindingType = typeToJavaType(question.binding.type)
			if (questionInputType !== bindingType) {
				error("Cannot assign input of type " + questionInputType + " to binding of type " + bindingType + ".", IF22Package.Literals.QUESTION__BINDING)
			}
		}
	}
	
	@Check
	def ensureValidationExpressionReturnBoolean(Question question) {
		if (!(question.validate instanceof TypeValue)) {
			if (getExpressionOutputType(question.validate) != 'boolean') {
				error("Only boolean expressions are valid in input validation.", IF22Package.Literals.QUESTION__VALIDATE)
			}
		}
	}
	
	@Check
	def ensureTargetConditionReturnBoolean(Target target) {
		if (target.condition !== null) {
			if (getExpressionOutputType(target.condition) != 'boolean') {
				error('Only boolean expressions are valid in the transition condition.', IF22Package.Literals.TARGET__CONDITION)
			}
		}
	}
}
