/*
 * generated by Xtext 2.26.0
 */
package lomzt.mdsd.exam.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import lomzt.mdsd.exam.iF22.Story
import lomzt.mdsd.exam.iF22.Scenario
import lomzt.mdsd.exam.iF22.Location
import lomzt.mdsd.exam.iF22.Announce
import lomzt.mdsd.exam.iF22.Question
import lomzt.mdsd.exam.iF22.End
import lomzt.mdsd.exam.iF22.Expression
import lomzt.mdsd.exam.iF22.And
import lomzt.mdsd.exam.iF22.Or
import lomzt.mdsd.exam.iF22.Equals
import lomzt.mdsd.exam.iF22.NotEquals
import lomzt.mdsd.exam.iF22.Greater
import lomzt.mdsd.exam.iF22.Lesser
import lomzt.mdsd.exam.iF22.GreaterOrEquals
import lomzt.mdsd.exam.iF22.LesserOrEquals
import lomzt.mdsd.exam.iF22.Div
import lomzt.mdsd.exam.iF22.Mult
import lomzt.mdsd.exam.iF22.Minus
import lomzt.mdsd.exam.iF22.Plus
import lomzt.mdsd.exam.iF22.Concat
import lomzt.mdsd.exam.iF22.Type
import lomzt.mdsd.exam.iF22.BooleanTrue
import lomzt.mdsd.exam.iF22.BooleanFalse
import lomzt.mdsd.exam.iF22.StringValue
import lomzt.mdsd.exam.iF22.NumberValue
import lomzt.mdsd.exam.iF22.VariableUse
import lomzt.mdsd.exam.iF22.Parenthesis
import lomzt.mdsd.exam.iF22.ExternalCall
import lomzt.mdsd.exam.iF22.Not
import lomzt.mdsd.exam.iF22.Binding
import lomzt.mdsd.exam.iF22.VarBinding
import lomzt.mdsd.exam.iF22.Parameter
import lomzt.mdsd.exam.iF22.Text
import lomzt.mdsd.exam.iF22.This
import java.util.stream.Collectors
import static lomzt.mdsd.exam.Utilities.*
import lomzt.mdsd.exam.iF22.Target
import lomzt.mdsd.exam.iF22.EndingTarget
import java.util.List
import lomzt.mdsd.exam.iF22.TypeValue

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class IF22Generator extends AbstractGenerator {

	static final val PACKAGE = "interactive_fiction"
	static final val QUESTION_LAST_INPUT = "__last_input"
	static final val PARAM_LETTERS = "abcdefghijklmnopqrstuvxyzæøå"
	
	static var paramIndex = 0;
	static Question currentQuestion = null;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val story = resource.allContents.filter(Story).next();

		fsa.generateFile(PACKAGE + "/common/Scenario.java", scenarioBaseClass())
		fsa.generateFile(PACKAGE + "/" + story.name.toSnakeCase + "/" + "Game.java", story.compileMainClass)
		fsa.generateFile(PACKAGE + "/" + story.name.toSnakeCase + "/" + "External.java", story.compileExternalInterface)

		for (scenario : story.scenarios) {
			fsa.generateFile(PACKAGE + "/" + story.name.toSnakeCase + "/" + "Scenario" + scenario.name + ".java",
				scenario.compileScenarioClass)
		}
	}

	static def scenarioBaseClass() '''
		package interactive_fiction.common;
		
		import java.io.BufferedReader;
		import java.io.InputStreamReader;
		import java.io.IOException;
		
		public abstract class Scenario {
			protected static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
			protected String nextInteraction;
			protected String calledScenarioEnd;
			
			public abstract String interact() throws IOException ;
			
			public static void changeInput(InputStreamReader streamReader) {
				br = new BufferedReader(streamReader);
			}
		}
	'''

	static def compileMainClass(Story story) '''
		package interactive_fiction.«story.name.toSnakeCase»;
		
		import java.io.IOException;
		import interactive_fiction.common.*;
		
		public class Game{
			public Scenario start;
			
			«IF story.hasExternalImports»
			public Game(External external) {
				this.start = new «story.scenarios.get(0).className»(external);
			}
			«ELSE»
			public Game() {
				this.start = new «story.scenarios.get(0).className»();
			}
			«ENDIF»
			
			public void play()  throws IOException {
				start.interact();
			}
		}
	'''

	static def compileScenarioClass(Scenario scenario) '''
		package interactive_fiction.«getParentOfType(scenario, typeof(Story)).name.toSnakeCase»;
		
		import java.io.IOException;
		import interactive_fiction.common.*;
		
		class «scenario.className» extends Scenario {
			
			External external;
			String «QUESTION_LAST_INPUT»;
			
			«scenario.compileBindings»
			
			public «scenario.className»(«String.join(", ", scenario.params.stream().map(x | x.paramToJavaParam as CharSequence).collect(Collectors.toList()))») { 
				«FOR param : scenario.params»
					«param.bindingName» = «param.name»;
				«ENDFOR»
			}
			
			public «scenario.className»(«String.join(", ", scenario.params.stream().map(x | x.paramToJavaParam as CharSequence).collect(Collectors.toList()))»«addPrefixIfAnyInList('External external', ', ', scenario.params)») {
				this.external = external;
				«FOR param : scenario.params»
					«param.bindingName» = «param.name»;
				«ENDFOR»
			}
			
			public String interact() throws IOException {
				String calledScenarioEnd = null;
				nextInteraction = "«scenario.locations.get(0).name»";
				while(true){
					try {
						switch(nextInteraction){
							«FOR location : scenario.locations»
								case "«location.name»":
									«location.compileScenarioLocation»
							«ENDFOR»
						}
					} catch (Exception ex) {
						System.out.println("An error occured, please try again..");
						break;
					}
				}
				
				return null;
			}
		}
	'''
	
	static def hasExternalImports (Story story) {
		return story.imports.size() > 0;
	}
	
	// i hate this
	static def addPrefixIfAnyInList(String input, String prefix, List list) {
		if (list.size() > 0) {
			return prefix + input;
		}else{
			return input;
		}
	}

	static def compileExternalInterface(Story story) '''
		
		package interactive_fiction.«story.name.toSnakeCase»;
		
		public interface External {
			«FOR importFuncs : story.imports»
				public «typeToJavaType(importFuncs.returnType)» «importFuncs.name»(«String.join(", ", importFuncs.params.stream().map(x | typeToJavaType(x) + " " + getParamLetter()
		).collect(Collectors.toList()))»);
			«ENDFOR»
		}
	'''

	static def getParamLetter() {
		val index = paramIndex++ % PARAM_LETTERS.length()
		return PARAM_LETTERS.charAt(index)
	}

	static def paramToJavaParam(Parameter parameter) {
		return typeToJavaType(parameter.type) + " " + parameter.name
	}

	static def compileBindings(Scenario scenario) {
		val bindings = getChildrenOfType(scenario, typeof(Binding))
		return '''
			«FOR binding : bindings»
				«binding.compileBinding»
			«ENDFOR»
		'''
	}

	static def compileBinding(Binding binding) {
		switch (binding) {
			VarBinding: typeToJavaType(binding.type) + " " + binding.bindingName + ";"
			Parameter: typeToJavaType(binding.type) + " " + binding.bindingName + ";"
		}
	}

	static dispatch def compileScenarioLocation(Announce announce) '''
		«IF announce.text !== null»
			«announce.text.compilePrintout»
		«ENDIF»
		«FOR target : announce.targets»
			«target.compileTarget»
		«ENDFOR»
		break;
	'''

	static dispatch def compileScenarioLocation(Question question) '''
		«IF question.text !== null»
			«question.text.compilePrintout»
		«ENDIF»
		«{ currentQuestion = question; ''}»
		«QUESTION_LAST_INPUT» = br.readLine();
		«question.defineThisBinding» = «compileConvertInputTo(QUESTION_LAST_INPUT, inputType(question))»;
		«IF !(question.validate instanceof TypeValue)»
		if (!(«question.validate.compileExpression»)) {
			throw new Exception("Invalid input, please try again.");
		}
		«ENDIF»
		«IF question.binding !== null»
			«question.binding.bindingName» = «compileConvertInputTo(QUESTION_LAST_INPUT, inputType(question))»;
		«ENDIF»
		«FOR target : question.targets»
			«target.compileTarget»
		«ENDFOR»
		break;
	'''
	
	static def defineThisBinding (Question question) {
		return inputType(question) + " " + question.thisBinding
	}
	
	static def thisBinding (Question question) {
		'__this_' + question.name
	}

	static dispatch def compileScenarioLocation(End end) '''
		«IF end.text !== null»
			«end.text.compilePrintout»
		«ENDIF»
		return "«end.name»";
	'''

	static def compilePrintout(Expression exp) '''
		System.out.println(«exp.compileExpression»);
	'''

	static def compileTarget(Target target) '''
		«IF target.condition !== null»
			if («target.condition.compileExpression») {
				«target.compileTransition»
				break;
			}
		«ELSE»
			«target.compileTransition»
		«ENDIF»
	'''

	static def compileTransition(Target target) '''
		«IF target.target instanceof Location»
			nextInteraction = "«target.target.name»";
		«ELSEIF target.target instanceof Scenario»
			calledScenarioEnd = new «(target.target as Scenario).className»(«String.join (",", target.args.stream().map(x | x.compileExpression).collect(Collectors.toList()))»«addPrefixIfAnyInList('external', ', ', target.args)»).interact();
			«FOR et : target.endingTargets»
				«et.compileEndingTarget»
			«ENDFOR»
		«ENDIF»
	'''

	static def compileEndingTarget(EndingTarget endingTarget) '''
		if (calledScenarioEnd.equals("«endingTarget.from.name»")) {
			nextInteraction = "«endingTarget.target.target.name»";
			break;
		}
	'''

	static def className(Scenario scenario) {
		return "Scenario" + scenario.name
	}

	static def readBr(Type readAs) {
		switch (readAs) {
			lomzt.mdsd.exam.iF22.Number: "Integer.parseInt(br.readLine())"
			lomzt.mdsd.exam.iF22.Boolean: "Boolean.parseBoolean(br.readline())"
			Text: "br.readLine()"
		}
	}

	static def bindingName(Binding binding) {
		switch (binding) {
			VarBinding: "__var_" + binding.name
			Parameter: "__param_" + binding.name
		}
	}
	
	static dispatch def compileConvertInputTo(String str, Type type) {
		switch (type) {
			lomzt.mdsd.exam.iF22.Number: 'Integer.parseInt(' + str + ')'
			lomzt.mdsd.exam.iF22.Boolean: 'Boolean.parseBoolean(' + str + ')'
			Text: str + '.toString()'
		}
	}
	
	static dispatch def compileConvertInputTo(String str, String javaType) {
		switch (javaType) {
			case 'int': 'Integer.parseInt(' + str + ')'
			case 'boolean': 'Boolean.parseBoolean(' + str + ')'
			case 'String': str + '.toString()'
		}
	}
	
	static dispatch def properEquals(Equals eq) {
		val anyString = getExpressionOutputType(eq.left) == 'String' || getExpressionOutputType(eq.right) == 'String'
		if (anyString) {
			return '''«eq.left.compileExpression».equals(«eq.right.compileExpression»)'''
		}else{
			return eq.left.compileExpression + " == " + eq.right.compileExpression
		}
	}
	
	static dispatch def properEquals(NotEquals neq) {
		val anyString = getExpressionOutputType(neq.left) == 'String' || getExpressionOutputType(neq.right) == 'String'
		if (anyString) {
			return '''(!«neq.left.compileExpression».equals(«neq.right.compileExpression»))'''
		}else{
			return neq.left.compileExpression + " == " + neq.right.compileExpression
		}
	}

	static def CharSequence compileExpression(Expression exp) {
		switch (exp) {
			And: exp.left.compileExpression + " && " + exp.right.compileExpression
			Or: exp.left.compileExpression + " || " + exp.right.compileExpression
			Equals: exp.properEquals
			NotEquals: exp.properEquals
			Greater: exp.left.compileExpression + " > " + exp.right.compileExpression
			Lesser: exp.left.compileExpression + " < " + exp.right.compileExpression
			GreaterOrEquals: exp.left.compileExpression + " >= " + exp.right.compileExpression
			LesserOrEquals: exp.left.compileExpression + " <= " + exp.right.compileExpression
			Concat: exp.left.compileExpression + " + " + exp.right.compileExpression
			Plus: exp.left.compileExpression + " + " + exp.right.compileExpression
			Minus: exp.left.compileExpression + " - " + exp.right.compileExpression
			Mult: exp.left.compileExpression + " * " + exp.right.compileExpression
			Div: exp.left.compileExpression + " / " + exp.right.compileExpression
			TypeValue: thisBinding(currentQuestion)
			This: thisBinding(currentQuestion)
			BooleanTrue: 'true'
			BooleanFalse: 'false'
			StringValue: "\"" + exp.value.toString() + "\""
			NumberValue: exp.value.toString()
			VariableUse: exp.ref.bindingName
			Parenthesis: '(' + exp.exp.compileExpression + ')'
			ExternalCall: 'external.' + exp.func.name + "(" + String.join(",", exp.args.stream().map( x | x.compileExpression).collect(Collectors.toList())) + ")"
			Not: '!' + exp.exp.compileExpression
		}
	}

	static def toSnakeCase(String text) {
		var result = "";
		val starting = text.charAt(0)
		result += Character.toLowerCase(starting)
		for (var i = 1; i < text.length; i++) {
			val character = text.charAt(i)
			if (Character.isUpperCase(character)) {
				result += "_" + Character.toLowerCase(character);
			} else {
				result += character;
			}
		}
		return result;
	}
}
