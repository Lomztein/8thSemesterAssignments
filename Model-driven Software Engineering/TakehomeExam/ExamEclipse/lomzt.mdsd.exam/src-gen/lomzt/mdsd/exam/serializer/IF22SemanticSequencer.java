/*
 * generated by Xtext 2.26.0
 */
package lomzt.mdsd.exam.serializer;

import com.google.inject.Inject;
import java.util.Set;
import lomzt.mdsd.exam.iF22.And;
import lomzt.mdsd.exam.iF22.Announce;
import lomzt.mdsd.exam.iF22.BooleanFalse;
import lomzt.mdsd.exam.iF22.BooleanTrue;
import lomzt.mdsd.exam.iF22.Concat;
import lomzt.mdsd.exam.iF22.Div;
import lomzt.mdsd.exam.iF22.End;
import lomzt.mdsd.exam.iF22.EndingTarget;
import lomzt.mdsd.exam.iF22.Equals;
import lomzt.mdsd.exam.iF22.ExternalCall;
import lomzt.mdsd.exam.iF22.ExternalImport;
import lomzt.mdsd.exam.iF22.Greater;
import lomzt.mdsd.exam.iF22.GreaterOrEquals;
import lomzt.mdsd.exam.iF22.IF22Package;
import lomzt.mdsd.exam.iF22.Lesser;
import lomzt.mdsd.exam.iF22.LesserOrEquals;
import lomzt.mdsd.exam.iF22.Minus;
import lomzt.mdsd.exam.iF22.Mult;
import lomzt.mdsd.exam.iF22.Not;
import lomzt.mdsd.exam.iF22.NotEquals;
import lomzt.mdsd.exam.iF22.NumberValue;
import lomzt.mdsd.exam.iF22.Or;
import lomzt.mdsd.exam.iF22.Parenthesis;
import lomzt.mdsd.exam.iF22.Plus;
import lomzt.mdsd.exam.iF22.Question;
import lomzt.mdsd.exam.iF22.Scenario;
import lomzt.mdsd.exam.iF22.Story;
import lomzt.mdsd.exam.iF22.StringValue;
import lomzt.mdsd.exam.iF22.Target;
import lomzt.mdsd.exam.iF22.Text;
import lomzt.mdsd.exam.iF22.This;
import lomzt.mdsd.exam.iF22.TypeValue;
import lomzt.mdsd.exam.iF22.VarBinding;
import lomzt.mdsd.exam.iF22.VariableUse;
import lomzt.mdsd.exam.services.IF22GrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class IF22SemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private IF22GrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == IF22Package.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case IF22Package.AND:
				sequence_Exp(context, (And) semanticObject); 
				return; 
			case IF22Package.ANNOUNCE:
				sequence_Announce(context, (Announce) semanticObject); 
				return; 
			case IF22Package.BOOLEAN:
				sequence_Type(context, (lomzt.mdsd.exam.iF22.Boolean) semanticObject); 
				return; 
			case IF22Package.BOOLEAN_FALSE:
				sequence_Primary(context, (BooleanFalse) semanticObject); 
				return; 
			case IF22Package.BOOLEAN_TRUE:
				sequence_Primary(context, (BooleanTrue) semanticObject); 
				return; 
			case IF22Package.CONCAT:
				sequence_Concatonation(context, (Concat) semanticObject); 
				return; 
			case IF22Package.DIV:
				sequence_MultiplicationDivision(context, (Div) semanticObject); 
				return; 
			case IF22Package.END:
				sequence_End(context, (End) semanticObject); 
				return; 
			case IF22Package.ENDING_TARGET:
				sequence_EndingTarget(context, (EndingTarget) semanticObject); 
				return; 
			case IF22Package.EQUALS:
				sequence_EqualsOrNotEquals(context, (Equals) semanticObject); 
				return; 
			case IF22Package.EXTERNAL_CALL:
				sequence_Primary(context, (ExternalCall) semanticObject); 
				return; 
			case IF22Package.EXTERNAL_IMPORT:
				sequence_ExternalImport(context, (ExternalImport) semanticObject); 
				return; 
			case IF22Package.GREATER:
				sequence_Compare(context, (Greater) semanticObject); 
				return; 
			case IF22Package.GREATER_OR_EQUALS:
				sequence_Compare(context, (GreaterOrEquals) semanticObject); 
				return; 
			case IF22Package.LESSER:
				sequence_Compare(context, (Lesser) semanticObject); 
				return; 
			case IF22Package.LESSER_OR_EQUALS:
				sequence_Compare(context, (LesserOrEquals) semanticObject); 
				return; 
			case IF22Package.MINUS:
				sequence_AdditionSubtraction(context, (Minus) semanticObject); 
				return; 
			case IF22Package.MULT:
				sequence_MultiplicationDivision(context, (Mult) semanticObject); 
				return; 
			case IF22Package.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case IF22Package.NOT_EQUALS:
				sequence_EqualsOrNotEquals(context, (NotEquals) semanticObject); 
				return; 
			case IF22Package.NUMBER:
				sequence_Type(context, (lomzt.mdsd.exam.iF22.Number) semanticObject); 
				return; 
			case IF22Package.NUMBER_VALUE:
				sequence_Primary(context, (NumberValue) semanticObject); 
				return; 
			case IF22Package.OR:
				sequence_Exp(context, (Or) semanticObject); 
				return; 
			case IF22Package.PARAMETER:
				sequence_Parameter(context, (lomzt.mdsd.exam.iF22.Parameter) semanticObject); 
				return; 
			case IF22Package.PARENTHESIS:
				sequence_Primary(context, (Parenthesis) semanticObject); 
				return; 
			case IF22Package.PLUS:
				sequence_AdditionSubtraction(context, (Plus) semanticObject); 
				return; 
			case IF22Package.QUESTION:
				sequence_Question(context, (Question) semanticObject); 
				return; 
			case IF22Package.SCENARIO:
				sequence_Scenario(context, (Scenario) semanticObject); 
				return; 
			case IF22Package.STORY:
				sequence_Story(context, (Story) semanticObject); 
				return; 
			case IF22Package.STRING_VALUE:
				sequence_Primary(context, (StringValue) semanticObject); 
				return; 
			case IF22Package.TARGET:
				sequence_Target(context, (Target) semanticObject); 
				return; 
			case IF22Package.TEXT:
				sequence_Type(context, (Text) semanticObject); 
				return; 
			case IF22Package.THIS:
				sequence_Primary(context, (This) semanticObject); 
				return; 
			case IF22Package.TYPE_VALUE:
				sequence_Primary(context, (TypeValue) semanticObject); 
				return; 
			case IF22Package.VAR_BINDING:
				sequence_VarBinding(context, (VarBinding) semanticObject); 
				return; 
			case IF22Package.VARIABLE_USE:
				sequence_Primary(context, (VariableUse) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Minus
	 *     Exp.And_1_0_0_0 returns Minus
	 *     Exp.Or_1_0_1_0 returns Minus
	 *     EqualsOrNotEquals returns Minus
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns Minus
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns Minus
	 *     Compare returns Minus
	 *     Compare.Greater_1_0_0_0 returns Minus
	 *     Compare.Lesser_1_0_1_0 returns Minus
	 *     Compare.GreaterOrEquals_1_0_2_0 returns Minus
	 *     Compare.LesserOrEquals_1_0_3_0 returns Minus
	 *     Concatonation returns Minus
	 *     Concatonation.Concat_1_0_0 returns Minus
	 *     AdditionSubtraction returns Minus
	 *     AdditionSubtraction.Plus_1_0_0_0 returns Minus
	 *     AdditionSubtraction.Minus_1_0_1_0 returns Minus
	 *
	 * Constraint:
	 *     (left=AdditionSubtraction_Minus_1_0_1_0 right=MultiplicationDivision)
	 * </pre>
	 */
	protected void sequence_AdditionSubtraction(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionSubtractionAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionSubtractionAccess().getRightMultiplicationDivisionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Plus
	 *     Exp.And_1_0_0_0 returns Plus
	 *     Exp.Or_1_0_1_0 returns Plus
	 *     EqualsOrNotEquals returns Plus
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns Plus
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns Plus
	 *     Compare returns Plus
	 *     Compare.Greater_1_0_0_0 returns Plus
	 *     Compare.Lesser_1_0_1_0 returns Plus
	 *     Compare.GreaterOrEquals_1_0_2_0 returns Plus
	 *     Compare.LesserOrEquals_1_0_3_0 returns Plus
	 *     Concatonation returns Plus
	 *     Concatonation.Concat_1_0_0 returns Plus
	 *     AdditionSubtraction returns Plus
	 *     AdditionSubtraction.Plus_1_0_0_0 returns Plus
	 *     AdditionSubtraction.Minus_1_0_1_0 returns Plus
	 *
	 * Constraint:
	 *     (left=AdditionSubtraction_Plus_1_0_0_0 right=MultiplicationDivision)
	 * </pre>
	 */
	protected void sequence_AdditionSubtraction(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionSubtractionAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionSubtractionAccess().getRightMultiplicationDivisionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Location returns Announce
	 *     Announce returns Announce
	 *     Targetable returns Announce
	 *
	 * Constraint:
	 *     (name=ID text=Exp? targets+=Target+)
	 * </pre>
	 */
	protected void sequence_Announce(ISerializationContext context, Announce semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Greater
	 *     Exp.And_1_0_0_0 returns Greater
	 *     Exp.Or_1_0_1_0 returns Greater
	 *     EqualsOrNotEquals returns Greater
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns Greater
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns Greater
	 *     Compare returns Greater
	 *     Compare.Greater_1_0_0_0 returns Greater
	 *     Compare.Lesser_1_0_1_0 returns Greater
	 *     Compare.GreaterOrEquals_1_0_2_0 returns Greater
	 *     Compare.LesserOrEquals_1_0_3_0 returns Greater
	 *
	 * Constraint:
	 *     (left=Compare_Greater_1_0_0_0 right=Concatonation)
	 * </pre>
	 */
	protected void sequence_Compare(ISerializationContext context, Greater semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.GREATER__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.GREATER__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.GREATER__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.GREATER__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareAccess().getGreaterLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareAccess().getRightConcatonationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns GreaterOrEquals
	 *     Exp.And_1_0_0_0 returns GreaterOrEquals
	 *     Exp.Or_1_0_1_0 returns GreaterOrEquals
	 *     EqualsOrNotEquals returns GreaterOrEquals
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns GreaterOrEquals
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns GreaterOrEquals
	 *     Compare returns GreaterOrEquals
	 *     Compare.Greater_1_0_0_0 returns GreaterOrEquals
	 *     Compare.Lesser_1_0_1_0 returns GreaterOrEquals
	 *     Compare.GreaterOrEquals_1_0_2_0 returns GreaterOrEquals
	 *     Compare.LesserOrEquals_1_0_3_0 returns GreaterOrEquals
	 *
	 * Constraint:
	 *     (left=Compare_GreaterOrEquals_1_0_2_0 right=Concatonation)
	 * </pre>
	 */
	protected void sequence_Compare(ISerializationContext context, GreaterOrEquals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.GREATER_OR_EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.GREATER_OR_EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.GREATER_OR_EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.GREATER_OR_EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareAccess().getGreaterOrEqualsLeftAction_1_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareAccess().getRightConcatonationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Lesser
	 *     Exp.And_1_0_0_0 returns Lesser
	 *     Exp.Or_1_0_1_0 returns Lesser
	 *     EqualsOrNotEquals returns Lesser
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns Lesser
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns Lesser
	 *     Compare returns Lesser
	 *     Compare.Greater_1_0_0_0 returns Lesser
	 *     Compare.Lesser_1_0_1_0 returns Lesser
	 *     Compare.GreaterOrEquals_1_0_2_0 returns Lesser
	 *     Compare.LesserOrEquals_1_0_3_0 returns Lesser
	 *
	 * Constraint:
	 *     (left=Compare_Lesser_1_0_1_0 right=Concatonation)
	 * </pre>
	 */
	protected void sequence_Compare(ISerializationContext context, Lesser semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.LESSER__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.LESSER__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.LESSER__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.LESSER__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareAccess().getLesserLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareAccess().getRightConcatonationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns LesserOrEquals
	 *     Exp.And_1_0_0_0 returns LesserOrEquals
	 *     Exp.Or_1_0_1_0 returns LesserOrEquals
	 *     EqualsOrNotEquals returns LesserOrEquals
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns LesserOrEquals
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns LesserOrEquals
	 *     Compare returns LesserOrEquals
	 *     Compare.Greater_1_0_0_0 returns LesserOrEquals
	 *     Compare.Lesser_1_0_1_0 returns LesserOrEquals
	 *     Compare.GreaterOrEquals_1_0_2_0 returns LesserOrEquals
	 *     Compare.LesserOrEquals_1_0_3_0 returns LesserOrEquals
	 *
	 * Constraint:
	 *     (left=Compare_LesserOrEquals_1_0_3_0 right=Concatonation)
	 * </pre>
	 */
	protected void sequence_Compare(ISerializationContext context, LesserOrEquals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.LESSER_OR_EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.LESSER_OR_EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.LESSER_OR_EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.LESSER_OR_EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareAccess().getLesserOrEqualsLeftAction_1_0_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareAccess().getRightConcatonationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Concat
	 *     Exp.And_1_0_0_0 returns Concat
	 *     Exp.Or_1_0_1_0 returns Concat
	 *     EqualsOrNotEquals returns Concat
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns Concat
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns Concat
	 *     Compare returns Concat
	 *     Compare.Greater_1_0_0_0 returns Concat
	 *     Compare.Lesser_1_0_1_0 returns Concat
	 *     Compare.GreaterOrEquals_1_0_2_0 returns Concat
	 *     Compare.LesserOrEquals_1_0_3_0 returns Concat
	 *     Concatonation returns Concat
	 *     Concatonation.Concat_1_0_0 returns Concat
	 *
	 * Constraint:
	 *     (left=Concatonation_Concat_1_0_0 right=AdditionSubtraction)
	 * </pre>
	 */
	protected void sequence_Concatonation(ISerializationContext context, Concat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.CONCAT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.CONCAT__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.CONCAT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.CONCAT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConcatonationAccess().getConcatLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConcatonationAccess().getRightAdditionSubtractionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Location returns End
	 *     End returns End
	 *     Targetable returns End
	 *
	 * Constraint:
	 *     (name=ID text=Exp?)
	 * </pre>
	 */
	protected void sequence_End(ISerializationContext context, End semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EndingTarget returns EndingTarget
	 *
	 * Constraint:
	 *     (from=[Location|ID] target=Target)
	 * </pre>
	 */
	protected void sequence_EndingTarget(ISerializationContext context, EndingTarget semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.ENDING_TARGET__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.ENDING_TARGET__FROM));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.ENDING_TARGET__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.ENDING_TARGET__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndingTargetAccess().getFromLocationIDTerminalRuleCall_1_0_1(), semanticObject.eGet(IF22Package.Literals.ENDING_TARGET__FROM, false));
		feeder.accept(grammarAccess.getEndingTargetAccess().getTargetTargetParserRuleCall_2_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Equals
	 *     Exp.And_1_0_0_0 returns Equals
	 *     Exp.Or_1_0_1_0 returns Equals
	 *     EqualsOrNotEquals returns Equals
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns Equals
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns Equals
	 *
	 * Constraint:
	 *     (left=EqualsOrNotEquals_Equals_1_0_0_0 right=Compare)
	 * </pre>
	 */
	protected void sequence_EqualsOrNotEquals(ISerializationContext context, Equals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualsOrNotEqualsAccess().getEqualsLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualsOrNotEqualsAccess().getRightCompareParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns NotEquals
	 *     Exp.And_1_0_0_0 returns NotEquals
	 *     Exp.Or_1_0_1_0 returns NotEquals
	 *     EqualsOrNotEquals returns NotEquals
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns NotEquals
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns NotEquals
	 *
	 * Constraint:
	 *     (left=EqualsOrNotEquals_NotEquals_1_0_1_0 right=Compare)
	 * </pre>
	 */
	protected void sequence_EqualsOrNotEquals(ISerializationContext context, NotEquals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.NOT_EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.NOT_EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.NOT_EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.NOT_EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualsOrNotEqualsAccess().getNotEqualsLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualsOrNotEqualsAccess().getRightCompareParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns And
	 *     Exp.And_1_0_0_0 returns And
	 *     Exp.Or_1_0_1_0 returns And
	 *
	 * Constraint:
	 *     (left=Exp_And_1_0_0_0 right=EqualsOrNotEquals)
	 * </pre>
	 */
	protected void sequence_Exp(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpAccess().getAndLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpAccess().getRightEqualsOrNotEqualsParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Or
	 *     Exp.And_1_0_0_0 returns Or
	 *     Exp.Or_1_0_1_0 returns Or
	 *
	 * Constraint:
	 *     (left=Exp_Or_1_0_1_0 right=EqualsOrNotEquals)
	 * </pre>
	 */
	protected void sequence_Exp(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpAccess().getOrLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpAccess().getRightEqualsOrNotEqualsParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExternalImport returns ExternalImport
	 *
	 * Constraint:
	 *     (name=ID params+=Type? params+=Type* returnType=Type)
	 * </pre>
	 */
	protected void sequence_ExternalImport(ISerializationContext context, ExternalImport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Div
	 *     Exp.And_1_0_0_0 returns Div
	 *     Exp.Or_1_0_1_0 returns Div
	 *     EqualsOrNotEquals returns Div
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns Div
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns Div
	 *     Compare returns Div
	 *     Compare.Greater_1_0_0_0 returns Div
	 *     Compare.Lesser_1_0_1_0 returns Div
	 *     Compare.GreaterOrEquals_1_0_2_0 returns Div
	 *     Compare.LesserOrEquals_1_0_3_0 returns Div
	 *     Concatonation returns Div
	 *     Concatonation.Concat_1_0_0 returns Div
	 *     AdditionSubtraction returns Div
	 *     AdditionSubtraction.Plus_1_0_0_0 returns Div
	 *     AdditionSubtraction.Minus_1_0_1_0 returns Div
	 *     MultiplicationDivision returns Div
	 *     MultiplicationDivision.Mult_1_0_0_0 returns Div
	 *     MultiplicationDivision.Div_1_0_1_0 returns Div
	 *
	 * Constraint:
	 *     (left=MultiplicationDivision_Div_1_0_1_0 right=Primary)
	 * </pre>
	 */
	protected void sequence_MultiplicationDivision(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationDivisionAccess().getDivLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationDivisionAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Mult
	 *     Exp.And_1_0_0_0 returns Mult
	 *     Exp.Or_1_0_1_0 returns Mult
	 *     EqualsOrNotEquals returns Mult
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns Mult
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns Mult
	 *     Compare returns Mult
	 *     Compare.Greater_1_0_0_0 returns Mult
	 *     Compare.Lesser_1_0_1_0 returns Mult
	 *     Compare.GreaterOrEquals_1_0_2_0 returns Mult
	 *     Compare.LesserOrEquals_1_0_3_0 returns Mult
	 *     Concatonation returns Mult
	 *     Concatonation.Concat_1_0_0 returns Mult
	 *     AdditionSubtraction returns Mult
	 *     AdditionSubtraction.Plus_1_0_0_0 returns Mult
	 *     AdditionSubtraction.Minus_1_0_1_0 returns Mult
	 *     MultiplicationDivision returns Mult
	 *     MultiplicationDivision.Mult_1_0_0_0 returns Mult
	 *     MultiplicationDivision.Div_1_0_1_0 returns Mult
	 *
	 * Constraint:
	 *     (left=MultiplicationDivision_Mult_1_0_0_0 right=Primary)
	 * </pre>
	 */
	protected void sequence_MultiplicationDivision(ISerializationContext context, Mult semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.MULT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.MULT__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.MULT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.MULT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationDivisionAccess().getMultLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationDivisionAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *     Binding returns Parameter
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, lomzt.mdsd.exam.iF22.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.BINDING__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.BINDING__NAME));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.BINDING__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.BINDING__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns BooleanFalse
	 *     Exp.And_1_0_0_0 returns BooleanFalse
	 *     Exp.Or_1_0_1_0 returns BooleanFalse
	 *     EqualsOrNotEquals returns BooleanFalse
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns BooleanFalse
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns BooleanFalse
	 *     Compare returns BooleanFalse
	 *     Compare.Greater_1_0_0_0 returns BooleanFalse
	 *     Compare.Lesser_1_0_1_0 returns BooleanFalse
	 *     Compare.GreaterOrEquals_1_0_2_0 returns BooleanFalse
	 *     Compare.LesserOrEquals_1_0_3_0 returns BooleanFalse
	 *     Concatonation returns BooleanFalse
	 *     Concatonation.Concat_1_0_0 returns BooleanFalse
	 *     AdditionSubtraction returns BooleanFalse
	 *     AdditionSubtraction.Plus_1_0_0_0 returns BooleanFalse
	 *     AdditionSubtraction.Minus_1_0_1_0 returns BooleanFalse
	 *     MultiplicationDivision returns BooleanFalse
	 *     MultiplicationDivision.Mult_1_0_0_0 returns BooleanFalse
	 *     MultiplicationDivision.Div_1_0_1_0 returns BooleanFalse
	 *     Primary returns BooleanFalse
	 *
	 * Constraint:
	 *     {BooleanFalse}
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, BooleanFalse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns BooleanTrue
	 *     Exp.And_1_0_0_0 returns BooleanTrue
	 *     Exp.Or_1_0_1_0 returns BooleanTrue
	 *     EqualsOrNotEquals returns BooleanTrue
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns BooleanTrue
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns BooleanTrue
	 *     Compare returns BooleanTrue
	 *     Compare.Greater_1_0_0_0 returns BooleanTrue
	 *     Compare.Lesser_1_0_1_0 returns BooleanTrue
	 *     Compare.GreaterOrEquals_1_0_2_0 returns BooleanTrue
	 *     Compare.LesserOrEquals_1_0_3_0 returns BooleanTrue
	 *     Concatonation returns BooleanTrue
	 *     Concatonation.Concat_1_0_0 returns BooleanTrue
	 *     AdditionSubtraction returns BooleanTrue
	 *     AdditionSubtraction.Plus_1_0_0_0 returns BooleanTrue
	 *     AdditionSubtraction.Minus_1_0_1_0 returns BooleanTrue
	 *     MultiplicationDivision returns BooleanTrue
	 *     MultiplicationDivision.Mult_1_0_0_0 returns BooleanTrue
	 *     MultiplicationDivision.Div_1_0_1_0 returns BooleanTrue
	 *     Primary returns BooleanTrue
	 *
	 * Constraint:
	 *     {BooleanTrue}
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, BooleanTrue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns ExternalCall
	 *     Exp.And_1_0_0_0 returns ExternalCall
	 *     Exp.Or_1_0_1_0 returns ExternalCall
	 *     EqualsOrNotEquals returns ExternalCall
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns ExternalCall
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns ExternalCall
	 *     Compare returns ExternalCall
	 *     Compare.Greater_1_0_0_0 returns ExternalCall
	 *     Compare.Lesser_1_0_1_0 returns ExternalCall
	 *     Compare.GreaterOrEquals_1_0_2_0 returns ExternalCall
	 *     Compare.LesserOrEquals_1_0_3_0 returns ExternalCall
	 *     Concatonation returns ExternalCall
	 *     Concatonation.Concat_1_0_0 returns ExternalCall
	 *     AdditionSubtraction returns ExternalCall
	 *     AdditionSubtraction.Plus_1_0_0_0 returns ExternalCall
	 *     AdditionSubtraction.Minus_1_0_1_0 returns ExternalCall
	 *     MultiplicationDivision returns ExternalCall
	 *     MultiplicationDivision.Mult_1_0_0_0 returns ExternalCall
	 *     MultiplicationDivision.Div_1_0_1_0 returns ExternalCall
	 *     Primary returns ExternalCall
	 *
	 * Constraint:
	 *     (func=[ExternalImport|ID] args+=Exp? args+=Exp*)
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, ExternalCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Not
	 *     Exp.And_1_0_0_0 returns Not
	 *     Exp.Or_1_0_1_0 returns Not
	 *     EqualsOrNotEquals returns Not
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns Not
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns Not
	 *     Compare returns Not
	 *     Compare.Greater_1_0_0_0 returns Not
	 *     Compare.Lesser_1_0_1_0 returns Not
	 *     Compare.GreaterOrEquals_1_0_2_0 returns Not
	 *     Compare.LesserOrEquals_1_0_3_0 returns Not
	 *     Concatonation returns Not
	 *     Concatonation.Concat_1_0_0 returns Not
	 *     AdditionSubtraction returns Not
	 *     AdditionSubtraction.Plus_1_0_0_0 returns Not
	 *     AdditionSubtraction.Minus_1_0_1_0 returns Not
	 *     MultiplicationDivision returns Not
	 *     MultiplicationDivision.Mult_1_0_0_0 returns Not
	 *     MultiplicationDivision.Div_1_0_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     exp=Exp
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.NOT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.NOT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpExpParserRuleCall_9_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns NumberValue
	 *     Exp.And_1_0_0_0 returns NumberValue
	 *     Exp.Or_1_0_1_0 returns NumberValue
	 *     EqualsOrNotEquals returns NumberValue
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns NumberValue
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns NumberValue
	 *     Compare returns NumberValue
	 *     Compare.Greater_1_0_0_0 returns NumberValue
	 *     Compare.Lesser_1_0_1_0 returns NumberValue
	 *     Compare.GreaterOrEquals_1_0_2_0 returns NumberValue
	 *     Compare.LesserOrEquals_1_0_3_0 returns NumberValue
	 *     Concatonation returns NumberValue
	 *     Concatonation.Concat_1_0_0 returns NumberValue
	 *     AdditionSubtraction returns NumberValue
	 *     AdditionSubtraction.Plus_1_0_0_0 returns NumberValue
	 *     AdditionSubtraction.Minus_1_0_1_0 returns NumberValue
	 *     MultiplicationDivision returns NumberValue
	 *     MultiplicationDivision.Mult_1_0_0_0 returns NumberValue
	 *     MultiplicationDivision.Div_1_0_1_0 returns NumberValue
	 *     Primary returns NumberValue
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, NumberValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.NUMBER_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.NUMBER_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getValueINTTerminalRuleCall_5_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Parenthesis
	 *     Exp.And_1_0_0_0 returns Parenthesis
	 *     Exp.Or_1_0_1_0 returns Parenthesis
	 *     EqualsOrNotEquals returns Parenthesis
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns Parenthesis
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns Parenthesis
	 *     Compare returns Parenthesis
	 *     Compare.Greater_1_0_0_0 returns Parenthesis
	 *     Compare.Lesser_1_0_1_0 returns Parenthesis
	 *     Compare.GreaterOrEquals_1_0_2_0 returns Parenthesis
	 *     Compare.LesserOrEquals_1_0_3_0 returns Parenthesis
	 *     Concatonation returns Parenthesis
	 *     Concatonation.Concat_1_0_0 returns Parenthesis
	 *     AdditionSubtraction returns Parenthesis
	 *     AdditionSubtraction.Plus_1_0_0_0 returns Parenthesis
	 *     AdditionSubtraction.Minus_1_0_1_0 returns Parenthesis
	 *     MultiplicationDivision returns Parenthesis
	 *     MultiplicationDivision.Mult_1_0_0_0 returns Parenthesis
	 *     MultiplicationDivision.Div_1_0_1_0 returns Parenthesis
	 *     Primary returns Parenthesis
	 *
	 * Constraint:
	 *     exp=Exp
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, Parenthesis semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.PARENTHESIS__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.PARENTHESIS__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpExpParserRuleCall_7_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns StringValue
	 *     Exp.And_1_0_0_0 returns StringValue
	 *     Exp.Or_1_0_1_0 returns StringValue
	 *     EqualsOrNotEquals returns StringValue
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns StringValue
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns StringValue
	 *     Compare returns StringValue
	 *     Compare.Greater_1_0_0_0 returns StringValue
	 *     Compare.Lesser_1_0_1_0 returns StringValue
	 *     Compare.GreaterOrEquals_1_0_2_0 returns StringValue
	 *     Compare.LesserOrEquals_1_0_3_0 returns StringValue
	 *     Concatonation returns StringValue
	 *     Concatonation.Concat_1_0_0 returns StringValue
	 *     AdditionSubtraction returns StringValue
	 *     AdditionSubtraction.Plus_1_0_0_0 returns StringValue
	 *     AdditionSubtraction.Minus_1_0_1_0 returns StringValue
	 *     MultiplicationDivision returns StringValue
	 *     MultiplicationDivision.Mult_1_0_0_0 returns StringValue
	 *     MultiplicationDivision.Div_1_0_1_0 returns StringValue
	 *     Primary returns StringValue
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, StringValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.STRING_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.STRING_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getValueSTRINGTerminalRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns This
	 *     Exp.And_1_0_0_0 returns This
	 *     Exp.Or_1_0_1_0 returns This
	 *     EqualsOrNotEquals returns This
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns This
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns This
	 *     Compare returns This
	 *     Compare.Greater_1_0_0_0 returns This
	 *     Compare.Lesser_1_0_1_0 returns This
	 *     Compare.GreaterOrEquals_1_0_2_0 returns This
	 *     Compare.LesserOrEquals_1_0_3_0 returns This
	 *     Concatonation returns This
	 *     Concatonation.Concat_1_0_0 returns This
	 *     AdditionSubtraction returns This
	 *     AdditionSubtraction.Plus_1_0_0_0 returns This
	 *     AdditionSubtraction.Minus_1_0_1_0 returns This
	 *     MultiplicationDivision returns This
	 *     MultiplicationDivision.Mult_1_0_0_0 returns This
	 *     MultiplicationDivision.Div_1_0_1_0 returns This
	 *     Primary returns This
	 *
	 * Constraint:
	 *     {This}
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, This semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns TypeValue
	 *     Exp.And_1_0_0_0 returns TypeValue
	 *     Exp.Or_1_0_1_0 returns TypeValue
	 *     EqualsOrNotEquals returns TypeValue
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns TypeValue
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns TypeValue
	 *     Compare returns TypeValue
	 *     Compare.Greater_1_0_0_0 returns TypeValue
	 *     Compare.Lesser_1_0_1_0 returns TypeValue
	 *     Compare.GreaterOrEquals_1_0_2_0 returns TypeValue
	 *     Compare.LesserOrEquals_1_0_3_0 returns TypeValue
	 *     Concatonation returns TypeValue
	 *     Concatonation.Concat_1_0_0 returns TypeValue
	 *     AdditionSubtraction returns TypeValue
	 *     AdditionSubtraction.Plus_1_0_0_0 returns TypeValue
	 *     AdditionSubtraction.Minus_1_0_1_0 returns TypeValue
	 *     MultiplicationDivision returns TypeValue
	 *     MultiplicationDivision.Mult_1_0_0_0 returns TypeValue
	 *     MultiplicationDivision.Div_1_0_1_0 returns TypeValue
	 *     Primary returns TypeValue
	 *
	 * Constraint:
	 *     type=Type
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, TypeValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.TYPE_VALUE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.TYPE_VALUE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getTypeTypeParserRuleCall_0_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns VariableUse
	 *     Exp.And_1_0_0_0 returns VariableUse
	 *     Exp.Or_1_0_1_0 returns VariableUse
	 *     EqualsOrNotEquals returns VariableUse
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns VariableUse
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns VariableUse
	 *     Compare returns VariableUse
	 *     Compare.Greater_1_0_0_0 returns VariableUse
	 *     Compare.Lesser_1_0_1_0 returns VariableUse
	 *     Compare.GreaterOrEquals_1_0_2_0 returns VariableUse
	 *     Compare.LesserOrEquals_1_0_3_0 returns VariableUse
	 *     Concatonation returns VariableUse
	 *     Concatonation.Concat_1_0_0 returns VariableUse
	 *     AdditionSubtraction returns VariableUse
	 *     AdditionSubtraction.Plus_1_0_0_0 returns VariableUse
	 *     AdditionSubtraction.Minus_1_0_1_0 returns VariableUse
	 *     MultiplicationDivision returns VariableUse
	 *     MultiplicationDivision.Mult_1_0_0_0 returns VariableUse
	 *     MultiplicationDivision.Div_1_0_1_0 returns VariableUse
	 *     Primary returns VariableUse
	 *
	 * Constraint:
	 *     ref=[Binding|ID]
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, VariableUse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.VARIABLE_USE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.VARIABLE_USE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getRefBindingIDTerminalRuleCall_6_1_0_1(), semanticObject.eGet(IF22Package.Literals.VARIABLE_USE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Location returns Question
	 *     Question returns Question
	 *     Targetable returns Question
	 *
	 * Constraint:
	 *     (name=ID text=Exp? validate=Exp binding=[VarBinding|ID]? targets+=Target+)
	 * </pre>
	 */
	protected void sequence_Question(ISerializationContext context, Question semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Scenario returns Scenario
	 *     Targetable returns Scenario
	 *
	 * Constraint:
	 *     (name=ID (params+=Parameter params+=Parameter*)? bindings+=VarBinding* locations+=Location+)
	 * </pre>
	 */
	protected void sequence_Scenario(ISerializationContext context, Scenario semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Story returns Story
	 *
	 * Constraint:
	 *     (name=ID imports+=ExternalImport* scenarios+=Scenario*)
	 * </pre>
	 */
	protected void sequence_Story(ISerializationContext context, Story semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Target returns Target
	 *
	 * Constraint:
	 *     (target=[Targetable|ID] (args+=Exp args+=Exp*)? condition=Exp? endingTargets+=EndingTarget*)
	 * </pre>
	 */
	protected void sequence_Target(ISerializationContext context, Target semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns Boolean
	 *
	 * Constraint:
	 *     {Boolean}
	 * </pre>
	 */
	protected void sequence_Type(ISerializationContext context, lomzt.mdsd.exam.iF22.Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns Number
	 *
	 * Constraint:
	 *     {Number}
	 * </pre>
	 */
	protected void sequence_Type(ISerializationContext context, lomzt.mdsd.exam.iF22.Number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns Text
	 *
	 * Constraint:
	 *     {Text}
	 * </pre>
	 */
	protected void sequence_Type(ISerializationContext context, Text semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VarBinding returns VarBinding
	 *     Binding returns VarBinding
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 * </pre>
	 */
	protected void sequence_VarBinding(ISerializationContext context, VarBinding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.BINDING__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.BINDING__NAME));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.BINDING__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.BINDING__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarBindingAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVarBindingAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
}
