/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator


import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.Exp
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.Litteral
import dk.sdu.mmmi.mdsd.math.VariableUse
import dk.sdu.mmmi.mdsd.math.LetEnd
import dk.sdu.mmmi.mdsd.math.Parenthesis
/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	static Map<String, Integer> variables = new HashMap();
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.allContents.filter(MathExp).next
		val result = model.compute
			
		// You can replace with hovering, see Bettini Chapter 8
		result.displayPanel
	}
	
	//
	// Compute function: computes value of expression
	// Note: written according to illegal left-recursive grammar, requires fix
	//
	
	def static compute(MathExp math) {
		val count = math.assignments.length
		for (var i = 0; i < count; i++) {
			val assignment = math.assignments.get(i)
			
			variables.put(assignment.name, assignment.exp.computeExp)
		}
		
		return variables
	}
	
	def static int computeExp(Exp exp) {
		switch exp {
			Plus: exp.left.computeExp + exp.right.computeExp
			Minus: exp.left.computeExp - exp.right.computeExp
			Mult: exp.left.computeExp * exp.right.computeExp
			Div: exp.left.computeExp / exp.right.computeExp
			Parenthesis: exp.computeParenthesis
			VariableUse: exp.computeVariableUse
			LetEnd: exp.computeLetEnd
			Litteral: exp.value
			default: 0
		}
	}
	
	def static int computeVariableUse (VariableUse use) {
		return variables.get(use.ref.name)
	}
	
	def static int computeParenthesis (Parenthesis par) {
		return par.exp.computeExp
	}
	
	def static int computeLetEnd (LetEnd le) {
		val leResult = le.exp.computeExp
		variables.put(le.name, leResult) // Might need a different, temporary container :thinking:
		val inResult = le.in.computeExp
		return inResult
	}

	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
}
