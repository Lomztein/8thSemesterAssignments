/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.LetBinding
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.MathNumber
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.VarBinding
import dk.sdu.mmmi.mdsd.math.VariableUse
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.io.File
import dk.sdu.mmmi.mdsd.math.ExternalDefinition
import dk.sdu.mmmi.mdsd.math.Expression
import dk.sdu.mmmi.mdsd.math.Parenthesis
import dk.sdu.mmmi.mdsd.math.ExternalCall
import java.util.ArrayList
import java.util.List
import dk.sdu.mmmi.mdsd.math.Binding

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {
	
	static Map<String, Integer> variables;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		val className = math.name;
		
		val builder = new StringBuilder();
		generateClass(builder, className, math);
		
		new File("math_expression").mkdirs()
		fsa.generateFile(className + ".java", builder.toString());
	}
	
	def static appendLine (StringBuilder builder, String string) {
		builder.append(string + "\n");
	}
	
	def static void generateClass (StringBuilder builder, String className, MathExp math) {
		builder.appendLine("package math_expression;\nimport java.util.function.IntSupplier;\npublic class " + className + " {\n");
		generateFields(builder, math, 1);
		builder.appendLine("\n\tprivate External external;")
		builder.appendLine("\n\tpublic " + className + "() { }\n")
		builder.appendLine("\n\tpublic " + className + "(External external) {\n\t\tthis.external = external;\n\t}\n")
		val lets = new ArrayList<LetBinding>()
		generateComputeFunction(builder, math, 1);
		generateExternalInterface(builder, math, 1)
		builder.appendLine("}")
	}
	
	def static void generateFields (StringBuilder builder, MathExp math, int indents) {
		for(varBinding: math.variables)
			builder.appendLine(indents.asIndents + "public int " + varBinding.name + ";");
	}
	
	def static void generateLetFunctions (StringBuilder builder, List<LetBinding> lets, int indents) {
		val cur = new ArrayList<LetBinding>(lets);
		for (binding: cur) {
			lets.remove(binding);
			generateLetFunction(builder, binding, indents, lets);
		}
	}
	
	def static void generateLetFunction (StringBuilder builder, LetBinding binding, int indents, List<LetBinding> lets) {
		val localBuilder = new StringBuilder();
		
		builder.appendLine(indents.asIndents + "IntSupplier let" + binding.fullyQualifiedName + " = () -> {");
		builder.appendLine(indents.asIndents + "\tint " + binding.name + " = " + binding.binding.generateExpression(lets, true) + ";");
		localBuilder.appendLine(indents.asIndents + "\treturn " + binding.body.generateExpression(lets, false) + ";");		
		localBuilder.appendLine(indents.asIndents + "};");
		
		if (lets.size() > 0) {
			generateLetFunctions(builder, lets, indents + 1);
		}
		
		builder.append(localBuilder.toString());
	}
	
	def static void generateComputeFunction (StringBuilder builder, MathExp math, int indents) {
		builder.appendLine(indents.asIndents + "public void compute () {");
		val localBuilder = new StringBuilder();
		val lets = new ArrayList<LetBinding>()
		for (varBinding: math.variables) {
			generateComputeStatement(localBuilder, varBinding, indents + 1, lets);
		}
		if (lets.size() > 0) {
			generateLetFunctions(builder, lets, indents + 1);
		}
		builder.append(localBuilder.toString());
		builder.appendLine(indents.asIndents + "}\n");
	}
	
	def static void generateComputeStatement (StringBuilder builder, VarBinding binding, int indents, List<LetBinding> lets) {
		builder.appendLine(indents.asIndents + binding.name + " = " + binding.expression.generateExpression(lets, true) + ";");
	}
	
	def static String generateExpression(Expression exp, List<LetBinding> lets, boolean forceThis) {
		switch exp {
			Plus: exp.left.generateExpression(lets, forceThis) + " + " + exp.right.generateExpression(lets, forceThis)
			Minus: exp.left.generateExpression(lets, forceThis) + " - " + exp.right.generateExpression(lets, forceThis)
			Mult: exp.left.generateExpression(lets, forceThis) + " * " + exp.right.generateExpression(lets, forceThis)
			Div: exp.left.generateExpression(lets, forceThis) + " / " + exp.right.generateExpression(lets, forceThis)
			Parenthesis: "(" + exp.exp.generateExpression(lets, forceThis) + ")"
			VariableUse: forceThis ? "this." + exp.ref.name : exp.ref.name
			MathNumber: exp.value.toString()
			LetBinding: exp.generateLetBinding(lets)
			ExternalCall: exp.generateExternalCall(lets, forceThis)
		}
	}
	
	def static String generateLetBinding(LetBinding binding, List<LetBinding> lets) {
		if (!lets.contains(binding)) {
			lets.add(binding)
		}else{
			return binding.name
		}
		return "let" + binding.fullyQualifiedName + ".getAsInt()";
	}
	
	def static String generateExternalCall (ExternalCall call, List<LetBinding> lets, boolean forceThis) {
		var index = 0;
		val builder = new StringBuilder();
		builder.append("this.external." + call.func.name + "(");
		for (arg: call.args) {
			index++;
			builder.append(arg.generateExpression(lets, forceThis));
			if (index != call.args.size()) {
				builder.append(", ");
			}
		}
		builder.append(")");
		return builder.toString();
	}
	
	def static String fullyQualifiedName (LetBinding binding) {
		var name = binding.name;
		var container = binding.eContainer;
		while (container !== null) {
			if (container instanceof Binding) {
				name += container.name;
			}
			container = container.eContainer;
		}
		return name;
	}
	
	def static void generateExternalInterface(StringBuilder builder, MathExp math, int indents) {
		builder.appendLine(indents.asIndents + "public interface External {\n");
		for (definition: math.externals) {
			generateExternalDefintion(builder, definition, indents + 1);
		}
		builder.appendLine("\n" + indents.asIndents + "}");
	}
	
	static val argNames = "abcdefghijklmnopqrstuvxyz";
	def static void generateExternalDefintion(StringBuilder builder, ExternalDefinition definition, int indents) {
		var index = 0;
		builder.append(indents.asIndents + "public int " + definition.name + "(");
		for (param: definition.params)	{
			val name = argNames.charAt(index++);
			builder.append(param.toString() + " " + name);
			if (index != definition.params.size()) {
				builder.append(", ");
			}
		}
		builder.append(");\n");
	}
	
	def static String asIndents(int num) {
		val builder = new StringBuilder(num * 2);
		for (var i = 0; i < num; i++) {
			builder.append("\t");
		}
		return builder.toString();
	}
	
	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	
}
